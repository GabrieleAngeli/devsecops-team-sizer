<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>DevSecOps Team Sizer — Heuristics-based</title>
  <style>
    :root{
      --bg1:#0b1020; --bg2:#0a1633;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.08);
      --line: rgba(255,255,255,.12);
      --text:#e9edf5;
      --muted: rgba(169,180,207,.95);
      --muted2: rgba(169,180,207,.75);
      --accent: #7dffcd;
      --warn: #ffce7a;
      --danger: #ff7a90;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background: radial-gradient(1200px 700px at 15% -10%, rgba(125,255,205,.22), transparent 60%),
                  radial-gradient(900px 600px at 90% 0%, rgba(255,206,122,.16), transparent 60%),
                  linear-gradient(180deg, var(--bg1), var(--bg2));
      min-height:100vh;
    }
    header{
      padding:22px 18px 8px;
      max-width:1200px;
      margin:0 auto;
    }
    h1{
      margin:0;
      font-size:22px;
      letter-spacing:.2px;
    }
    .sub{
      margin-top:8px;
      color:var(--muted);
      line-height:1.45;
      font-size:13px;
      max-width:980px;
    }
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      font-size:12px;
      color: var(--muted);
      margin-left:8px;
    }
    main{
      max-width:1200px;
      margin:0 auto;
      padding:10px 18px 40px;
      display:grid;
      gap:14px;
    }
    @media(max-width:1100px){
      main{grid-template-columns:1fr}
    }
    .card{
      background: var(--card);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      padding:14px;
      box-shadow: 0 10px 28px rgba(0,0,0,.22);
      overflow:hidden;
    }
    .hd{
      display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
      margin-bottom:10px;
    }
    .title{
      font-weight:800;
      letter-spacing:.2px;
      font-size:14px;
    }
    .muted{ color:var(--muted); font-size:12px; line-height:1.4}
    .muted2{ color:var(--muted2); font-size:12px; line-height:1.4}
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    @media(max-width:680px){
      .row{grid-template-columns:1fr}
    }
    label{
      display:block;
      font-size:12px;
      color:var(--muted);
      margin:4px 0 6px;
    }
    input, select, textarea{
      width:100%;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
    }
    input:focus, select:focus, textarea:focus{
      border-color: rgba(125,255,205,.55);
      box-shadow: 0 0 0 3px rgba(125,255,205,.12);
    }
    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:8px;
    }
    .chip{
      user-select:none;
      cursor:pointer;
      font-size:12px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.16);
      color: var(--muted);
      transition: .15s transform, .15s background, .15s border-color;
    }
    .chip:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.22); }
    .chip.on{
      background: rgba(125,255,205,.12);
      border-color: rgba(125,255,205,.45);
      color: var(--text);
    }
    .btns{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:12px;
      align-items:center;
    }
    button{
      cursor:pointer;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(125,255,205,.14);
      color: var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:700;
      letter-spacing:.15px;
      transition:.15s transform,.15s background,.15s border-color;
    }
    button:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,.22); }
    button.secondary{ background: rgba(0,0,0,.18); }
    button.warn{ background: rgba(255,206,122,.12); }
    button.danger{ background: rgba(255,122,144,.12); }
    .kpis{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      margin-top:8px;
    }
    @media(max-width:900px){ .kpis{ grid-template-columns: repeat(2, 1fr);} }
    .kpi{
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      padding:12px;
    }
    .kpi .k{ color: var(--muted); font-size:12px;}
    .kpi .v{ margin-top:4px; font-weight:900; font-size:18px; letter-spacing:.2px}
    .kpi .h{ margin-top:2px; color: var(--muted2); font-size:12px;}
    table{
      width:100%;
      border-collapse: collapse;
      margin-top:10px;
      font-size:12px;
    }
    th, td{
      padding:9px 8px;
      border-bottom:1px solid rgba(255,255,255,.10);
      vertical-align:top;
    }
    th{ color: var(--muted); text-align:left; font-weight:800;}
    td{ color: var(--text);}
    .right{ text-align:right; }
    .tag{
      display:inline-block;
      padding:2px 7px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.15);
      color: var(--muted);
      font-size:11px;
    }
    .sectionTitle{
      margin:14px 0 0;
      font-weight:900;
      font-size:13px;
      letter-spacing:.2px;
    }
    .small{ font-size:12px; color: var(--muted2); line-height:1.4; }
    .note{
      margin-top:10px;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      color: var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .canvasWrap{
      margin-top:10px;
      padding:10px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
    }
    canvas{ width:100%; height:260px; display:block; }
    .inline{
      display:flex;
      align-items:center;
      gap:10px;
      justify-content:space-between;
    }
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.75);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      padding: 10px 14px;
      color: var(--text);
      font-size: 12px;
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 9999;
    }
    .toast.on{ opacity:1; transform: translateX(-50%) translateY(-2px); }
  </style>
</head>
<body>
<header>
  <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap;">
    <h1>DevSecOps Team Sizer</h1>
    <span class="pill"><b>Heuristic</b> (not a guarantee)</span>
  </div>
  <p class="sub">
    Enter architecture pattern, stack, scale and criticality. The tool estimates a <b>complexity index</b>, suggests <b>team size</b>,
    <b>skills coverage</b> and a DevSecOps-oriented structure. Useful for early planning and trade-off discussions.
  </p>
</header>

<main>
  <!-- INPUT -->
  <section class="card">
    <div class="hd">
      <div>
        <div class="title">Product profile & expected load</div>
        <div class="muted">Inputs used to compute complexity and recommend team sizing.</div>
      </div>
      <div class="pill"><b>Inputs</b></div>
    </div>

    <div class="row">
      <div>
        <label for="pattern">Development / architecture pattern</label>
        <select id="pattern">
          <option value="monolith">Monolith (classic)</option>
          <option value="modular">Modular monolith (DDD / hexagon)</option>
          <option value="microservices">Microservices</option>
          <option value="eventdriven">Event-driven / streaming</option>
          <option value="serverless">Serverless / FaaS</option>
          <option value="hybrid">Hybrid (mixed)</option>
        </select>
      </div>
      <div>
        <label for="maturity">Current DevSecOps maturity</label>
        <select id="maturity">
          <option value="0">Low (manual, little automation)</option>
          <option value="1" selected>Medium (basic CI/CD, partial IaC)</option>
          <option value="2">High (strong pipelines, SRE, security-by-design)</option>
        </select>
      </div>
    </div>

    <div style="margin-top:12px;">
      <label>Technology categories in use (select all that apply)</label>
      <div class="chips" id="techChips"></div>
      <div class="small" style="margin-top:6px;">More categories typically means more integration surface, more tooling, and more specialized skills needed.</div>
    </div>

    <div class="row" style="margin-top:12px;">
      <div>
        <label for="traffic">Expected incoming traffic</label>
        <div class="row" style="grid-template-columns:1.3fr .7fr; margin-top:0;">
          <input id="traffic" type="number" min="0" step="1" value="50"/>
          <select id="trafficUnit">
            <option value="rps" selected>req/sec</option>
            <option value="rpm">req/min</option>
            <option value="dau">active users/day</option>
            <option value="mps">msg/sec (IoT)</option>
          </select>
        </div>
        <div class="small">Tip: 50 req/sec ≈ ~4.3M requests/day.</div>
      </div>
      <div>
        <label for="compute">Expected compute load</label>
        <input id="compute" type="range" min="1" max="10" value="5"/>
        <div class="inline">
          <span class="small">1 = light · 10 = heavy</span>
          <span class="pill"><b id="computeLabel">5/10</b></span>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <div>
        <label for="risk">Risk / criticality value (1–10)</label>
        <input id="risk" type="range" min="1" max="10" value="7"/>
        <div class="inline">
          <span class="small">Examples: banking=10 · e-commerce=8 · paid game=7</span>
          <span class="pill"><b id="riskLabel">7/10</b></span>
        </div>
      </div>
      <div>
        <label for="bias">Staffing approach</label>
        <select id="bias">
          <option value="lean">Lean (smaller team, more risk)</option>
          <option value="balanced" selected>Balanced</option>
          <option value="conservative">Conservative (more coverage, less risk)</option>
        </select>
      </div>
    </div>

    <div class="btns">
      <button id="btnCalc">Calculate</button>
      <button class="secondary" id="btnExample">Quick example</button>
      <button class="secondary" id="btnSave">Save scenario</button>
      <button class="danger" id="btnReset">Reset</button>
    </div>

    <div class="note">
      <b>How it works</b><br/>
      It computes a complexity index using: pattern factor, maturity factor, traffic scale, compute intensity, tech diversity and risk.
      Then it maps complexity to FTE + recommended roles for DevSecOps lifecycle coverage.
    </div>
  </section>

  <!-- OUTPUT -->
  <section class="card">
    <div class="hd">
      <div>
        <div class="title">Sizing & skills</div>
        <div class="muted">Recommendations + breakdown. Use this as a starting point, then adjust using real constraints.</div>
      </div>
      <div class="btns" style="margin-top:0;">
        <button class="secondary" id="btnDownloadJson">Download JSON</button>
      </div>
    </div>

    <div class="kpis">
      <div class="kpi">
        <div class="k">Complexity index</div>
        <div class="v" id="kComplexity">—</div>
        <div class="h" id="kComplexityHint">—</div>
      </div>
      <div class="kpi">
        <div class="k">Suggested headcount</div>
        <div class="v" id="kHeadcount">—</div>
        <div class="h" id="kHeadcountHint">—</div>
      </div>
      <div class="kpi">
        <div class="k"># Squads (feature teams)</div>
        <div class="v" id="kSquads">—</div>
        <div class="h" id="kSquadsHint">—</div>
      </div>
      <div class="kpi">
        <div class="k">Key driver</div>
        <div class="v" id="kDriver">—</div>
        <div class="h" id="kDriverHint">—</div>
      </div>
    </div>

    <div style="margin-top:14px;">
      <h3 class="sectionTitle">Recommended structure</h3>
      <div class="small" id="structureNote">—</div>
    </div>

    <div style="margin-top:14px;">
      <h3 class="sectionTitle">Drivers</h3>
      <table id="driversTbl">
        <thead>
          <tr><th>Factor</th><th class="right">Score</th><th>Reason</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div style="margin-top:14px;">
      <h3 class="sectionTitle">Suggested roles & FTE</h3>
      <table id="rolesTbl">
        <thead>
          <tr><th>Role</th><th class="right">FTE</th><th>Responsibilities (lifecycle)</th><th>Key skills</th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <div class="small" id="rolesHint"></div>
    </div>

    <div style="margin-top:14px;">
      <h3 class="sectionTitle">Skills matrix (coverage)</h3>
      <div class="small">Scale: 0=not needed · 1=basic · 2=good · 3=expert. (The tool estimates priority, it does not “measure” people.)</div>
      <table id="skillsTbl">
        <thead>
          <tr><th>Area</th><th class="right">Priority</th><th>Description</th><th>Examples</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div style="margin-top:16px;">
      <h3 class="sectionTitle">Cost: under / over staffing the team</h3>

      <div class="row" style="margin-top:8px;">
        <div>
          <label for="fteActual">Planned / actual FTE</label>
          <input id="fteActual" type="number" min="0" step="0.5" value="0"/>
          <div class="small">Tip: enter your real FTE (including part-time) to compare against the recommendation.</div>
        </div>
        <div>
          <label for="costFteYear">Average cost per FTE / year (fully-loaded)</label>
          <input id="costFteYear" type="number" min="0" step="1000" value="90000"/>
          <div class="small">Includes: salary + taxes + tooling + overhead (estimate). Use plain numbers (e.g. 90000). Comma/dot formats are accepted (e.g. 90,000 or 90.000).</div>
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label for="horizonMonths">Evaluation horizon (months)</label>
          <input id="horizonMonths" type="number" min="1" step="1" value="12"/>
          <div class="small">Typical: 6–12 months for delivery; 12+ for “stable operations”.</div>
        </div>
        <div>
          <label for="riskMultiplier">Risk cost multiplier (under-staffing)</label>
          <input id="riskMultiplier" type="number" min="0.5" step="0.1" value="1.2"/>
          <div class="small">Increases indirect cost of incidents, delays, rework and compliance pressure.</div>
        </div>
      </div>

      <div class="canvasWrap">
        <div class="inline">
          <div class="muted2">Lines: Salary (payroll), Total (salary + penalty/waste).</div>
          <span class="pill"><b id="costHintPill">—</b></span>
        </div>
        <canvas id="costChart" width="900" height="300"></canvas>
        <div class="small" id="costSummary"></div>

        <div class="note" style="margin-top:10px;">
          <b>How to read the cost chart</b><br/>
          This chart compares <b>total cost</b> (payroll + indirect effects) across different team sizes (FTE).
          <ul style="margin:8px 0 0 18px; color: rgba(169,180,207,.95);">
            <li><b>Under-staffing</b> (FTE &lt; recommended): the <span class="tag">under-penalty</span> grows → more delays, incidents, rework, and compliance risk.</li>
            <li><b>Over-staffing</b> (FTE &gt; recommended): the <span class="tag">waste/coordination</span> grows → more overhead, onboarding, meetings, merge conflicts, and duplicate work.</li>
            <li><span class="tag">Salary</span> is the baseline payroll cost; <span class="tag">Total</span> includes salary + penalty + waste.</li>
            <li>The vertical lines <span class="tag">recommended</span> and <span class="tag">actual</span> show where you are versus the suggested point.</li>
          </ul>
        </div>
      </div>
    </div>

    <div style="margin-top:16px;">
      <h3 class="sectionTitle">Time-to-production vs team size</h3>

      <div class="row" style="margin-top:8px;">
        <div>
          <label for="scopeMultiplier">Scope multiplier (release ambition)</label>
          <input id="scopeMultiplier" type="number" min="0.5" step="0.1" value="1.0"/>
          <div class="small">Higher = bigger release goal (more scope), thus more time.</div>
        </div>
        <div>
          <label for="handoffTax">Handoff / coordination tax</label>
          <input id="handoffTax" type="range" min="0" max="1" step="0.05" value="0.35"/>
          <div class="inline">
            <span class="small">Higher = more dependencies, policies, multi-team overhead.</span>
            <span class="pill"><b id="handoffTaxLabel">0.35</b></span>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:8px;">
        <div>
          <label for="workDaysPerWeek">Working days per week</label>
          <select id="workDaysPerWeek">
            <option value="5" selected>5 (Mon–Fri)</option>
            <option value="6">6 (Mon–Sat)</option>
          </select>
          <div class="small">The chart shows time in <b>working days</b>.</div>
        </div>
        <div></div>
      </div>

      <div class="canvasWrap">
        <div class="inline">
          <div class="muted2">Typical curve: improves up to a sweet spot, then plateaus (or worsens) due to coordination overhead. Y axis in <b>working days</b>.</div>
          <span class="pill"><b id="timeHintPill">Working days</b></span>
        </div>
        <canvas id="timeChart" width="900" height="300"></canvas>
        <div class="small" id="timeSummary"></div>

        <div class="note" style="margin-top:10px;">
          <b>How to read the time chart</b><br/>
          The curve estimates <b>time-to-production</b> in <b>working days</b> as team size (FTE) changes.
          <ul style="margin:8px 0 0 18px; color: rgba(169,180,207,.95);">
            <li>At first, adding people reduces time (more throughput).</li>
            <li>After a point, <b>coordination tax</b> (handoffs, dependencies, reviews, merges, communication) dominates → the curve plateaus or can even worsen.</li>
            <li><span class="tag">Scope multiplier</span> shifts the whole curve up/down (how big the release goal is).</li>
            <li><span class="tag">Handoff tax</span> models how “enterprise” the context is: higher = more overhead (policies, compliance, multi-team).</li>
            <li>The lines <span class="tag">recommended</span> and <span class="tag">actual</span> indicate the suggested sweet spot and your current position.</li>
          </ul>
        </div>
      </div>
    </div>

  </section>
</main>

<div class="toast" id="toast"></div>

<script>
(() => {
  // -----------------------------
  // Data
  const TECH = [
    { id:"frontend", label:"Web Frontend (SPA/MFE)" },
    { id:"mobile", label:"Mobile (iOS/Android)" },
    { id:"api", label:"Backend API (REST/GraphQL)" },
    { id:"grpc", label:"gRPC / RPC" },
    { id:"sqldb", label:"SQL DB (Postgres/MySQL/SQL Server)" },
    { id:"nosql", label:"NoSQL DB (Mongo/Cassandra/etc.)" },
    { id:"cache", label:"Cache (Redis/Ignite)" },
    { id:"broker", label:"Queue / Broker (RabbitMQ/ActiveMQ)" },
    { id:"stream", label:"Streaming (Kafka/Flink)" },
    { id:"search", label:"Search (Elastic/OpenSearch)" },
    { id:"k8s", label:"Kubernetes / Containers" },
    { id:"cloud", label:"Cloud managed services" },
    { id:"iac", label:"IaC (Terraform/Ansible)" },
    { id:"obs", label:"Observability (OpenTelemetry/Grafana)" },
    { id:"sec", label:"Security tooling (SAST/DAST/Secrets)" },
    { id:"cicd", label:"Advanced CI/CD" },
    { id:"ml", label:"ML/AI (inference/training)" },
  ];

  const PATTERN = {
    monolith:      { label:"Monolith", factor:1.00, note:"Simpler setup, less coordination overhead." },
    modular:       { label:"Modular monolith", factor:1.18, note:"Great trade-off: separation + single deployable." },
    microservices: { label:"Microservices", factor:1.45, note:"Overhead: contracts, CI/CD, observability, runtime ops." },
    eventdriven:   { label:"Event-driven", factor:1.55, note:"State, idempotency, ordering, schema evolution." },
    serverless:    { label:"Serverless", factor:1.35, note:"Great time-to-market; watch integration + cost." },
    hybrid:        { label:"Hybrid", factor:1.65, note:"Max flexibility, max organizational complexity." },
  };

  const MATURITY = {
    0: { label:"Low", factor:1.20, note:"More people needed to cover manual work and operational risk." },
    1: { label:"Medium", factor:1.00, note:"Automation baseline, good balance." },
    2: { label:"High", factor:0.88, note:"Strong automation reduces repetitive load and incidents." },
  };

  const BIAS = {
    lean:         { label:"Lean", hc:0.88, note:"Smaller team: accept more risk and operational debt." },
    balanced:     { label:"Balanced", hc:1.00, note:"Good balance between speed and coverage." },
    conservative: { label:"Conservative", hc:1.15, note:"More redundancy and specialization: less risk." },
  };

  const FACETS = [
    { id:"product", label:"Product & delivery", desc:"Discovery, scope, roadmap, prioritization, release planning." },
    { id:"backend", label:"Backend engineering", desc:"API design, data modeling, performance, resilience patterns." },
    { id:"frontend", label:"Frontend / UX", desc:"Web UI, micro-frontends, design systems, accessibility, performance." },
    { id:"data", label:"Data & storage", desc:"SQL/NoSQL modeling, migrations, retention, backup/restore." },
    { id:"platform", label:"Platform / SRE", desc:"Infra, k8s, reliability, capacity, incident response, on-call." },
    { id:"cicd", label:"CI/CD & release engineering", desc:"Pipelines, environments, deployment strategies, automation." },
    { id:"security", label:"Security & compliance", desc:"Threat modeling, secure SDLC, SAST/DAST, secrets, audits." },
    { id:"observability", label:"Observability", desc:"Tracing/metrics/logs, SLOs, dashboards, alerting." },
    { id:"qa", label:"Quality engineering", desc:"Test strategy, automation, performance tests, test data." },
    { id:"arch", label:"Architecture & governance", desc:"Boundaries, contracts, ADRs, standards, tech radar." },
  ];

  function facetExamples(id){
    switch(id){
      case "product": return ["roadmap", "backlog", "release plan"];
      case "backend": return ["API", "domain logic", "resilience"];
      case "frontend": return ["SPA/MFE", "design system", "perf budget"];
      case "data": return ["migrations", "indexes", "retention"];
      case "platform": return ["k8s", "IaC", "on-call"];
      case "cicd": return ["pipelines", "blue/green", "feature flags"];
      case "security": return ["SAST", "DAST", "secrets", "threat model"];
      case "observability": return ["OTel", "SLOs", "dashboards"];
      case "qa": return ["test automation", "load tests", "contract tests"];
      case "arch": return ["ADRs", "standards", "governance"];
      default: return ["—"];
    }
  }

  // -----------------------------
  // DOM helpers
  const el = (id) => document.getElementById(id);
  const toastEl = el("toast");
  function toast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add("on");
    setTimeout(() => toastEl.classList.remove("on"), 1600);
  }

  // Build tech chips
  const techChips = el("techChips");
  const selectedTech = new Set(["frontend","api","sqldb","cicd","obs","sec","k8s"]);
  TECH.forEach(t => {
    const d = document.createElement("div");
    d.className = "chip" + (selectedTech.has(t.id) ? " on" : "");
    d.textContent = t.label;
    d.dataset.id = t.id;
    d.addEventListener("click", () => {
      const id = d.dataset.id;
      if(selectedTech.has(id)){ selectedTech.delete(id); d.classList.remove("on"); }
      else { selectedTech.add(id); d.classList.add("on"); }
    });
    techChips.appendChild(d);
  });

  // Live labels
  const compute = el("compute");
  const risk = el("risk");
  const handoffTax = el("handoffTax");
  function syncSliders(){
    el("computeLabel").textContent = `${compute.value}/10`;
    el("riskLabel").textContent = `${risk.value}/10`;
    el("handoffTaxLabel").textContent = Number(handoffTax.value).toFixed(2);
  }
  compute.addEventListener("input", syncSliders);
  risk.addEventListener("input", syncSliders);
  handoffTax.addEventListener("input", syncSliders);
  syncSliders();

  // -----------------------------
  // Core model
  function toRps(value, unit){
    const v = Math.max(0, Number(value||0));
    if(unit === "rps") return v;
    if(unit === "rpm") return v / 60;
    if(unit === "mps") return v; // treat as msg/sec ~ rps scale
    if(unit === "dau"){
      // Assume avg 10 actions/user/day and 18 hours active window.
      const actions = v * 10;
      const seconds = 18 * 3600;
      return actions / seconds;
    }
    return v;
  }

  function scaleLabel(rps){
    if(rps <= 0.2) return "very low";
    if(rps <= 2) return "low";
    if(rps <= 20) return "medium";
    if(rps <= 100) return "high (already relevant)";
    if(rps <= 500) return "very high";
    return "extreme";
  }

  function computeLabel(x){
    const v = Number(x||0);
    if(v <= 3) return "light (CRUD / simple rules)";
    if(v <= 6) return "medium (aggregations / moderate compute)";
    if(v <= 8) return "heavy (real-time / batch + complex logic)";
    return "very heavy (ML / streaming / intensive workloads)";
  }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function parseLocaleNumber(val, fallback=0){
    if(val === null || val === undefined) return fallback;
    if(typeof val === "number") return Number.isFinite(val) ? val : fallback;
    let s = String(val).trim();
    if(!s) return fallback;

    // remove spaces and common currency symbols
    s = s.replace(/\s/g, "").replace(/[€$£]/g, "");

    const hasComma = s.includes(",");
    const hasDot = s.includes(".");

    if(hasComma && hasDot){
      // assume dot is thousands separator and comma is decimal separator
      s = s.replace(/\./g, "").replace(",", ".");
    } else if(hasComma && !hasDot){
      // comma as decimal separator
      s = s.replace(",", ".");
    } else if(hasDot && !hasComma){
      // dot could be decimal or thousands. If it looks like thousands grouping, remove dots.
      if(/^\d{1,3}(\.\d{3})+$/.test(s)){
        s = s.replace(/\./g, "");
      }
    }

    const n = parseFloat(s);
    return Number.isFinite(n) ? n : fallback;
  }


  function complexityIndex(input){
    const rps = toRps(input.traffic, input.trafficUnit);
    // scores 0..100 components
    const sTraffic = clamp((Math.log10(rps + 1) / Math.log10(500 + 1)) * 100, 0, 100);
    const sCompute = clamp((input.compute/10) * 100, 0, 100);
    const sTech = clamp((input.tech.length / 12) * 100, 0, 100);
    const sRisk = clamp((input.risk/10) * 100, 0, 100);

    const raw = 0.30*sTraffic + 0.25*sCompute + 0.20*sTech + 0.25*sRisk;
    const fact = PATTERN[input.pattern].factor * MATURITY[input.maturity].factor;
    const index = clamp(raw * fact, 0, 100);

    return { rps, sTraffic, sCompute, sTech, sRisk, raw, fact, index: Math.round(index) };
  }

  function skillPriorities(input, c){
    // return 0..3 per facet
    const pri = {};
    const base = c.index/100;

    const techSet = new Set(input.tech);
    const has = (id) => techSet.has(id);

    // Product: always needed; more with risk
    pri.product = clamp(Math.round(1 + base*1.2 + (input.risk/10)*1.0), 0, 3);

    // Backend: more if API/streaming/microservices
    pri.backend = clamp(Math.round(1 + base*1.5 + (has("api")?0.6:0) + (has("stream")?0.6:0)), 0, 3);

    // Frontend: if frontend/mobile selected
    pri.frontend = clamp(Math.round((has("frontend")||has("mobile")) ? (1 + base*1.0) : (base>0.65?1:0)), 0, 3);

    // Data: if DB/cache/streaming
    pri.data = clamp(Math.round(0.7 + base*1.3 + (has("sqldb")?0.5:0) + (has("nosql")?0.4:0) + (has("cache")?0.3:0) + (has("stream")?0.4:0)), 0, 3);

    // Platform/SRE: if k8s/cloud/stream/broker
    pri.platform = clamp(Math.round(0.7 + base*1.6 + (has("k8s")?0.8:0) + (has("cloud")?0.6:0) + (input.risk>=8?0.6:0)), 0, 3);

    // CI/CD: always; more if microservices
    pri.cicd = clamp(Math.round(1 + base*1.4 + (input.pattern==="microservices"?0.6:0)), 0, 3);

    // Security: strongly tied to risk
    pri.security = clamp(Math.round(0.7 + base*1.2 + (input.risk/10)*1.6 + (has("sec")?0.4:0)), 0, 3);

    // Observability: tied to scale and microservices
    pri.observability = clamp(Math.round(0.7 + base*1.2 + (c.sTraffic/100)*1.2 + (input.pattern!=="monolith"?0.3:0)), 0, 3);

    // QA: tied to risk + compute
    pri.qa = clamp(Math.round(0.6 + base*1.0 + (input.risk/10)*1.0 + (input.compute/10)*0.7), 0, 3);

    // Architecture/governance: more with microservices/hybrid
    pri.arch = clamp(Math.round(0.5 + base*1.0 + (input.pattern==="microservices"||input.pattern==="hybrid"?0.8:0)), 0, 3);

    return pri;
  }

  function recommendStaff(input, c){
    // Map complexity to FTE
    const base = 3.0 + (c.index/100)*11.0; // 3..14
    const bias = BIAS[input.bias].hc;
    const fteSum = Math.round((base*bias)*2)/2; // steps of 0.5

    // squads: start from 1, then grow slowly; keep squad size 5..8
    const squadSizeTarget = clamp(5 + (input.maturity==2?1:0), 5, 8);
    const squads = clamp(Math.round(fteSum / squadSizeTarget), 1, 6);
    const squadSize = Math.max(4, Math.round((fteSum / squads)));

    // Roles allocation
    const pri = skillPriorities(input, c);

    // Helper: assign role with fte + lifecycle + skills
    const role = (name, fte, lifecycle, skills) => ({ name, fte: Math.round(fte*2)/2, lifecycle, skills });

    const roles = [];

    // Product/PM
    const po = clamp(0.5 + pri.product*0.15 + (input.risk>=8?0.2:0), 0.5, 1.5);
    roles.push(role("Product Owner / PM", po, "Plan / Release", ["roadmap", "prioritization", "stakeholder mgmt"]));

    // Tech Lead / Architect
    const tl = clamp(0.7 + pri.arch*0.25 + (input.pattern==="microservices"?0.4:0), 0.8, 2.0);
    roles.push(role("Tech Lead / Architect", tl, "Design / Review", ["architecture", "boundaries", "standards", "ADR"]));

    // Backend engineers
    const be = clamp(1.0 + pri.backend*0.8 + (c.sTraffic>55?0.5:0) + (input.pattern==="microservices"?0.6:0), 1.0, 6.0);
    roles.push(role("Backend Engineer(s)", be, "Build / Operate", ["APIs", "data modeling", "resilience", "performance"]));

    // Frontend engineers
    const feNeed = (new Set(input.tech).has("frontend") || new Set(input.tech).has("mobile")) ? 1 : 0;
    const fe = clamp(feNeed*(0.8 + pri.frontend*0.7), 0, 4.0);
    if(fe>0) roles.push(role("Frontend Engineer(s)", fe, "Build / Release", ["UI", "UX", "state mgmt", "perf"]));

    // Data engineer / DBA-ish
    const de = clamp(0.3 + pri.data*0.45 + (new Set(input.tech).has("stream")?0.4:0), 0.3, 2.5);
    roles.push(role("Data / DB Engineer", de, "Design / Operate", ["migrations", "indexes", "retention", "backup"]));

    // Platform/SRE
    const sre = clamp(0.4 + pri.platform*0.55 + (input.maturity==0?0.3:0) + (c.sTraffic>65?0.4:0), 0.5, 3.5);
    roles.push(role("Platform / SRE", sre, "Operate / Improve", ["k8s", "IaC", "reliability", "incident response"]));

    // DevSecOps / Security engineer
    const sec = clamp(0.2 + pri.security*0.45 + (input.risk>=9?0.6:0), 0.25, 2.5);
    roles.push(role("Security / DevSecOps", sec, "Secure / Assure", ["threat modeling", "SAST/DAST", "secrets", "compliance"]));

    // QA / Test automation
    const qa = clamp(0.3 + pri.qa*0.45, 0.3, 2.5);
    roles.push(role("QA / Test Automation", qa, "Verify / Prevent", ["test strategy", "automation", "load tests"]));

    // Observability specialist (often in Platform/SRE; include only when needed)
    const obs = clamp(pri.observability>=2 ? (0.25 + (pri.observability-1)*0.25) : 0, 0, 1.5);
    if(obs>0) roles.push(role("Observability (shared)", obs, "Measure / Improve", ["OTel", "SLOs", "dashboards", "alerting"]));

    // Normalize totals roughly to fteSum (do not strictly force; just show recommended coverage)
    const sum = roles.reduce((a,r)=>a+r.fte,0);
    const scale = sum > 0 ? (fteSum / sum) : 1;
    const rolesScaled = roles.map(r => ({...r, fte: Math.round(r.fte*scale*2)/2 }));
    // Fix rounding drift
    let drift = Math.round((fteSum - rolesScaled.reduce((a,r)=>a+r.fte,0))*2)/2;
    if(Math.abs(drift) >= 0.5){
      rolesScaled[2].fte = Math.max(0, Math.round((rolesScaled[2].fte + drift)*2)/2); // adjust backend
    }

    const headcount = Math.max(2, Math.round(fteSum)); // rough
    const structureNote = `Suggested: ${squads} feature squad(s) (~${squadSize} people/squad) + a small platform/security layer (shared roles).`;

    return { headcount, fteSum, squads, squadSize, roles: rolesScaled, structureNote, pri };
  }

  // -----------------------------
  // Charts
  function money(n){
    const num = Number(n);
    if(!Number.isFinite(num)) return "€—";
    const v = Math.round(num);
    return "€" + v.toLocaleString("en-US");
  }

  function costModelForFte(fte, recFte, costFteYear, horizonMonths, input, c, riskMultiplier){
    const months = Math.max(1, Number(horizonMonths||12));
    const salaryCost = Math.max(0, fte) * Math.max(0, costFteYear) * (months/12);

    // Understaffing penalty scales with shortfall, risk, and complexity
    const shortfall = clamp((recFte - fte) / Math.max(0.5, recFte), 0, 1.5);
    const risk = (input.risk/10);
    const comp = (c.index/100);
    const basePenalty = salaryCost * (0.35 + 0.55*risk + 0.35*comp); // baseline multiplier
    const underPenalty = shortfall>0 ? basePenalty * shortfall * Math.max(0.5, riskMultiplier) : 0;

    // Overstaffing waste grows with surplus and coordination inefficiency
    const surplus = clamp((fte - recFte) / Math.max(0.5, recFte), 0, 2.0);
    const ineff = 0.12 + 0.10*(1 - MATURITY[input.maturity].factor) + 0.08*(input.pattern==="microservices" ? 1:0) + 0.06*comp;
    const overWaste = surplus>0 ? salaryCost * surplus * ineff : 0;

    const total = salaryCost + underPenalty + overWaste;
    return { salaryCost, underPenalty, overWaste, total };
  }

  function effectiveTeamThroughput(fte, handoffTax){
    // Throughput grows with team size but is reduced by coordination tax.
    const x = Math.max(0.5, fte);
    const tax = clamp(Number(handoffTax||0), 0, 1);
    // effective = x / (1 + tax*(x-1))  -> approaches 1/tax for large x
    return x / (1 + tax*(x-1));
  }

  function timeModelWeeks(fte, recFte, input, c, scopeMultiplier, handoffTax){
    // Base effort (in weeks) depends on complexity and architecture
    const base = 6 + (c.index/100)*18; // 6..24
    const patternOverhead = PATTERN[input.pattern].factor; // 1..1.65
    const scope = Math.max(0.5, Number(scopeMultiplier||1));

    // throughput baseline around recFte
    const eff = effectiveTeamThroughput(fte, handoffTax);
    const effNorm = effectiveTeamThroughput(recFte, handoffTax);

    const rel = eff / Math.max(0.4, effNorm); // relative to recommended point
    const weeks = (base * patternOverhead * scope) / Math.max(0.35, rel);

    // Avoid unrealistic ultra-low times
    return Math.max(2, weeks);
  }

  function weeksToWorkdays(weeks, wdPerWeek){
    const wd = Math.max(1, Number(wdPerWeek||5));
    return Math.max(0, Number(weeks||0)) * wd;
  }

  function fmtWorkdays(days){
    const d = Math.max(0, Number(days||0));
    const r = Math.round(d*2)/2;
    const asInt = Math.abs(r - Math.round(r)) < 0.001 ? String(Math.round(r)) : String(r);
    return `${asInt}wd`;
  }

  function drawLineChart(canvas, xs, series, opts){
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;

    const padL = 46, padR = 18, padT = 14, padB = 30;
    const innerW = W - padL - padR;
    const innerH = H - padT - padB;

    const allY = series.flatMap(s => s.ys);
    const minY = Math.min(...allY);
    const maxY = Math.max(...allY);
    const y0 = minY;
    const y1 = maxY + (maxY-minY)*0.08;

    const x0 = Math.min(...xs);
    const x1 = Math.max(...xs);

    const xMap = (x) => padL + ( (x - x0) / Math.max(0.0001, (x1-x0)) ) * innerW;
    const yMap = (y) => padT + innerH - ( (y - y0) / Math.max(0.0001, (y1-y0)) ) * innerH;

    // clear
    ctx.clearRect(0,0,W,H);

    // grid
    ctx.strokeStyle = "rgba(255,255,255,.10)";
    ctx.lineWidth = 1;
    for(let i=0;i<=4;i++){
      const yy = padT + (innerH/4)*i;
      ctx.beginPath();
      ctx.moveTo(padL, yy);
      ctx.lineTo(W-padR, yy);
      ctx.stroke();
    }

    // y labels
    ctx.fillStyle = "rgba(169,180,207,.85)";
    ctx.font = "12px ui-sans-serif, system-ui";
    for(let i=0;i<=4;i++){
      const yy = padT + (innerH/4)*i;
      const yVal = y1 - ( (y1-y0)/4 )*i;
      ctx.fillText(opts.yFmt ? opts.yFmt(yVal) : String(Math.round(yVal)), 6, yy+4);
    }

    // x labels
    ctx.fillText(opts.xLabel || "X", W/2-8, H-8);

    // series
    series.forEach(s => {
      ctx.strokeStyle = s.color || "rgba(125,255,205,.9)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      s.ys.forEach((y, i) => {
        const xx = xMap(xs[i]);
        const yy = yMap(y);
        if(i===0) ctx.moveTo(xx, yy);
        else ctx.lineTo(xx, yy);
      });
      ctx.stroke();
    });

    // vLines
    if(opts.vLines){
      opts.vLines.forEach(vl => {
        const xx = xMap(vl.x);
        ctx.save();
        ctx.strokeStyle = vl.color || "rgba(255,255,255,.25)";
        ctx.setLineDash(vl.dash || []);
        ctx.beginPath();
        ctx.moveTo(xx, padT);
        ctx.lineTo(xx, H-padB);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = vl.color || "rgba(255,255,255,.65)";
        ctx.fillText(vl.label || "", Math.min(W-90, xx+6), padT+12);
        ctx.restore();
      });
    }

    // Legend
    ctx.save();
    let lx = padL, ly = padT+2;
    series.forEach(s => {
      ctx.fillStyle = s.color || "rgba(125,255,205,.9)";
      ctx.fillRect(lx, ly, 10, 3);
      ctx.fillStyle = "rgba(233,237,245,.9)";
      ctx.fillText(s.name, lx+14, ly+5);
      lx += 120;
    });
    ctx.restore();
  }

  // -----------------------------
  // Rendering
  let currentState = null;

  function render(input, c, staff){
    // KPIs
    el("kComplexity").textContent = `${c.index}/100`;
    el("kComplexityHint").textContent = `Raw=${c.raw.toFixed(1)} · factor=${c.fact.toFixed(2)} · ${scaleLabel(c.rps)}`;
    el("kHeadcount").textContent = `${staff.headcount}`;
    el("kHeadcountHint").textContent = `Planned FTE: ${staff.fteSum}`;
    el("kSquads").textContent = `${staff.squads}`;
    el("kSquadsHint").textContent = `Target: ~${staff.squadSize} people/squad`;

    // Key driver (pick max contribution)
    const comps = [
      { name:"Traffic", score: c.sTraffic, why: `rps: ${c.rps.toFixed(2)} · ${scaleLabel(c.rps)}` },
      { name:"Compute", score: c.sCompute, why: computeLabel(input.compute) },
      { name:"Tech diversity", score: c.sTech, why: `${input.tech.length} categories` },
      { name:"Risk", score: c.sRisk, why: `Criticality ${input.risk}/10` },
      { name:"Maturity", score: MATURITY[input.maturity].factor*100, why: MATURITY[input.maturity].note },
      { name:"Pattern", score: PATTERN[input.pattern].factor*100, why: PATTERN[input.pattern].note },
    ].sort((a,b)=>b.score-a.score)[0];

    el("kDriver").textContent = comps.name;
    el("kDriverHint").textContent = comps.why;

    el("structureNote").textContent = staff.structureNote;

    // Drivers table
    const dBody = el("driversTbl").querySelector("tbody");
    dBody.innerHTML = "";
    const rows = [
      { name:"Pattern", score: PATTERN[input.pattern].factor.toFixed(2), why: PATTERN[input.pattern].note },
      { name:"Maturity", score: MATURITY[input.maturity].factor.toFixed(2), why: MATURITY[input.maturity].note },
      { name:"Traffic", score: Math.round(c.sTraffic*10)/10, why: `rps: ${c.rps.toFixed(2)} · ${scaleLabel(c.rps)}` },
      { name:"Compute", score: Math.round(c.sCompute*10)/10, why: computeLabel(input.compute) },
      { name:"Tech diversity", score: Math.round(c.sTech*10)/10, why: `${input.tech.length} categories` },
      { name:"Risk", score: Math.round(c.sRisk*10)/10, why: `Criticality ${input.risk}/10` },
    ];
    rows.forEach(r=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${r.name}</td><td class="right">${r.score}</td><td>${r.why}</td>`;
      dBody.appendChild(tr);
    });

    // Roles table
    const rBody = el("rolesTbl").querySelector("tbody");
    rBody.innerHTML = "";
    staff.roles.forEach(r=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td><b>${r.name}</b></td><td class="right">${r.fte}</td><td>${r.lifecycle}</td><td>${r.skills.map(s=>`<span class="tag">${s}</span>`).join(" ")}</td>`;
      rBody.appendChild(tr);
    });
    el("rolesHint").textContent = "Tip: for small teams, prioritize T-shaped profiles. Specialized roles can be part-time/shared.";

    // Skills matrix
    const sBody = el("skillsTbl").querySelector("tbody");
    sBody.innerHTML = "";
    FACETS.forEach(f=>{
      const v = staff.pri[f.id] ?? 0;
      const tr = document.createElement("tr");
      tr.innerHTML = `<td><b>${f.label}</b></td><td class="right">${v}/3</td><td>${f.desc}</td><td>${facetExamples(f.id).map(x=>`<span class="tag">${x}</span>`).join(" ")}</td>`;
      sBody.appendChild(tr);
    });

    // Seed chart comparisons
    el("fteActual").value = staff.fteSum;
    currentState = { input, c, staff, ts: Date.now() };
    try{ localStorage.setItem("devsecops_team_sizer:last", JSON.stringify(currentState)); }catch(e){}
    updateCharts();
  }

  function updateCharts(){
    const state = currentState || (()=>{ try{ return JSON.parse(localStorage.getItem("devsecops_team_sizer:last")||"null"); }catch(e){ return null; } })();
    if(!state) return;
    const { input, c, staff } = state;

    const recFte = Math.max(0.5, Number(staff.fteSum || staff.headcount || 1));
    const recFteRounded = Math.round(recFte*2)/2;

    const fteActual = Math.max(0.5, parseLocaleNumber(el("fteActual").value, recFte));
    const costFteYear = Math.max(0, parseLocaleNumber(el("costFteYear").value, 90000));
    const horizonMonths = Math.max(1, parseLocaleNumber(el("horizonMonths").value, 12));
    const riskMultiplier = Math.max(0.5, parseLocaleNumber(el("riskMultiplier").value, 1.2));

    const scopeMultiplier = Math.max(0.5, parseLocaleNumber(el("scopeMultiplier").value, 1.0));
    const tax = clamp(parseLocaleNumber(el("handoffTax").value, 0.35), 0, 1);
    const wdPerWeek = Math.max(1, parseLocaleNumber(el("workDaysPerWeek").value, 5));

    // X range around recommendation
    const minF = Math.max(0.5, Math.floor(recFte*0.5));
    const maxF = Math.min(30, Math.ceil(recFte*1.8 + 2));
    const xs = [];
    for(let x=minF; x<=maxF; x+=0.5) xs.push(Math.round(x*2)/2);

    // COST series
    const salaryYs = xs.map(x => costModelForFte(x, recFte, costFteYear, horizonMonths, input, c, riskMultiplier).salaryCost);
    const totalYs  = xs.map(x => costModelForFte(x, recFte, costFteYear, horizonMonths, input, c, riskMultiplier).total);

    drawLineChart(
      el("costChart"),
      xs,
      [
        { name:"Salary", ys: salaryYs, color:"rgba(255,206,122,.85)" },
        { name:"Total",  ys: totalYs,  color:"rgba(125,255,205,.9)" },
      ],
      {
        xLabel: "FTE",
        yFmt: (y) => money(y),
        vLines: [
          { x: recFteRounded, label:"recommended", color:"rgba(125,255,205,.8)" },
          { x: Math.round(fteActual*2)/2, label:"actual", color:"rgba(255,122,144,.85)", dash:[4,4] }
        ]
      }
    );

    const costRec = costModelForFte(recFte, recFte, costFteYear, horizonMonths, input, c, riskMultiplier);
    const costAct = costModelForFte(fteActual, recFte, costFteYear, horizonMonths, input, c, riskMultiplier);
    const delta = costAct.total - costRec.total;
    el("costHintPill").textContent = `Δ ${delta>=0?"+":"-"}${money(Math.abs(delta))}`;
    el("costSummary").textContent =
      `Estimated total cost over ${horizonMonths} months: recommended ≈ ${money(costRec.total)} · actual ≈ ${money(costAct.total)} (salary ${money(costAct.salaryCost)}, under-penalty ${money(costAct.underPenalty)}, waste ${money(costAct.overWaste)}).`;

    // TIME series (working days)
    const wdSeries = xs.map(x => weeksToWorkdays(timeModelWeeks(x, recFte, input, c, scopeMultiplier, tax), wdPerWeek));
    const wdRec = weeksToWorkdays(timeModelWeeks(recFte, recFte, input, c, scopeMultiplier, tax), wdPerWeek);
    const wdAct = weeksToWorkdays(timeModelWeeks(fteActual, recFte, input, c, scopeMultiplier, tax), wdPerWeek);

    drawLineChart(
      el("timeChart"),
      xs,
      [{ name:"Working days", ys: wdSeries, color:"rgba(125,255,205,.9)" }],
      {
        xLabel: "FTE",
        yFmt: (y) => Math.round(y) + "wd",
        vLines: [
          { x: recFteRounded, label:"recommended", color:"rgba(125,255,205,.8)" },
          { x: Math.round(fteActual*2)/2, label:"actual", color:"rgba(255,206,122,.85)", dash:[4,4] }
        ]
      }
    );

    el("timeSummary").textContent =
      `Estimated time-to-production: recommended ≈ ${fmtWorkdays(wdRec)} · actual ≈ ${fmtWorkdays(wdAct)} (${wdPerWeek} wd/week, scope ${scopeMultiplier.toFixed(1)}×, handoff tax ${tax.toFixed(2)}).`;
  }

  function readInput(){
    const input = {
      pattern: el("pattern").value,
      maturity: Number(el("maturity").value),
      tech: Array.from(selectedTech),
      traffic: parseLocaleNumber(el("traffic").value, 0),
      trafficUnit: el("trafficUnit").value,
      compute: parseLocaleNumber(el("compute").value, 5),
      risk: parseLocaleNumber(el("risk").value, 7),
      bias: el("bias").value,
    };
    return input;
  }

  function calculate(){
    const input = readInput();
    const c = complexityIndex(input);
    const staff = recommendStaff(input, c);
    render(input, c, staff);
    return { input, c, staff, ts: Date.now() };
  }

  // -----------------------------
  // Markdown report
  function mdEsc(s){ return String(s??"").replaceAll("|","\\|"); }

  function buildMarkdownReport(state){
    const { input, c, staff } = state;
    const techNames = (input.tech||[]).map(id => TECH.find(t=>t.id===id)?.label || id);

    // snapshot chart params
    const fteActual = Math.max(0.5, parseLocaleNumber(el("fteActual")?.value, staff.fteSum || 1));
    const costFteYear = Math.max(0, parseLocaleNumber(el("costFteYear")?.value, 90000));
    const horizonMonths = Math.max(1, parseLocaleNumber(el("horizonMonths")?.value, 12));
    const riskMultiplier = Math.max(0.5, parseLocaleNumber(el("riskMultiplier")?.value, 1.2));
    const scopeMultiplier = Math.max(0.5, parseLocaleNumber(el("scopeMultiplier")?.value, 1.0));
    const tax = clamp(parseLocaleNumber(el("handoffTax")?.value, 0.35), 0, 1);
    const wdPerWeek = Math.max(1, parseLocaleNumber(el("workDaysPerWeek")?.value, 5));

    const recFte = Math.max(0.5, Number(staff.fteSum || 1));
    const costRec = costModelForFte(recFte, recFte, costFteYear, horizonMonths, input, c, riskMultiplier);
    const costAct = costModelForFte(fteActual, recFte, costFteYear, horizonMonths, input, c, riskMultiplier);
    const costDelta = costAct.total - costRec.total;

    const wdRec = weeksToWorkdays(timeModelWeeks(recFte, recFte, input, c, scopeMultiplier, tax), wdPerWeek);
    const wdAct = weeksToWorkdays(timeModelWeeks(fteActual, recFte, input, c, scopeMultiplier, tax), wdPerWeek);
    const wdDelta = wdAct - wdRec;

    const lines = [];
    lines.push(`# DevSecOps Team Sizer — Report`);
    lines.push(`_Generated: ${new Date().toLocaleString("en-GB")}_`);
    lines.push("");
    lines.push(`## Inputs`);
    lines.push(`- Pattern: **${PATTERN[input.pattern].label}** (factor ${PATTERN[input.pattern].factor})`);
    lines.push(`- DevSecOps maturity: **${MATURITY[input.maturity].label}** (factor ${MATURITY[input.maturity].factor})`);
    lines.push(`- Staffing bias: **${BIAS[input.bias].label}** (×${BIAS[input.bias].hc})`);
    lines.push(`- Estimated traffic: **${c.rps.toFixed(2)} req/sec** (${input.traffic} ${input.trafficUnit})`);
    lines.push(`- Compute load: **${input.compute}/10** (${computeLabel(input.compute)})`);
    lines.push(`- Risk: **${input.risk}/10**`);
    lines.push(`- Technologies: ${techNames.length ? techNames.map(t => "\u0060"+t+"\u0060").join(", ") : "_n/a_"}`);
    lines.push("");

    lines.push(`## Summary output`);
    lines.push(`- Complexity index: **${c.index}/100** (raw ${c.raw.toFixed(1)} · factor ${c.fact.toFixed(2)})`);
    lines.push(`- Suggested headcount: **${staff.headcount}** (planned FTE: ${staff.fteSum})`);
    lines.push(`- Feature squads: **${staff.squads}** (~${staff.squadSize} people/squad)`);
    lines.push(`- Structure: ${staff.structureNote}`);
    lines.push("");

    lines.push(`## Driver scores (calculation breakdown)`);
    lines.push(`| Factor | Value | Note |`);
    lines.push(`|---|---:|---|`);
    lines.push(`| Pattern factor | ${PATTERN[input.pattern].factor} | ${mdEsc(PATTERN[input.pattern].note)} |`);
    lines.push(`| Maturity factor | ${MATURITY[input.maturity].factor} | ${mdEsc(MATURITY[input.maturity].note)} |`);
    lines.push(`| Traffic (rps) | ${c.rps.toFixed(2)} | score ${c.sTraffic.toFixed(1)} · ${scaleLabel(c.rps)} |`);
    lines.push(`| Compute | ${input.compute}/10 | score ${c.sCompute.toFixed(1)} · ${mdEsc(computeLabel(input.compute))} |`);
    lines.push(`| Tech diversity | ${input.tech.length} | score ${c.sTech.toFixed(1)} |`);
    lines.push(`| Risk | ${input.risk}/10 | score ${c.sRisk.toFixed(1)} |`);
    lines.push(`| Final index | ${c.index}/100 | raw=${c.raw.toFixed(1)} · factor=${c.fact.toFixed(2)} |`);
    lines.push("");

    lines.push(`## Suggested roles & FTE (details)`);
    lines.push(`| Role | FTE | Responsibilities (lifecycle) | Key skills |`);
    lines.push(`|---|---:|---|---|`);
    (staff.roles||[]).forEach(r=>{
      lines.push(`| ${mdEsc(r.name)} | ${r.fte} | ${mdEsc(r.lifecycle)} | ${mdEsc((r.skills||[]).join(", "))} |`);
    });
    lines.push("");

    lines.push(`## Skills matrix (coverage: 0..3)`);
    lines.push(`| Area | Priority | Description | Examples |`);
    lines.push(`|---|---:|---|---|`);
    FACETS.forEach(f=>{
      const v = staff.pri[f.id] ?? 0;
      lines.push(`| ${mdEsc(f.label)} | ${v}/3 | ${mdEsc(f.desc)} | ${mdEsc(facetExamples(f.id).join(", "))} |`);
    });
    lines.push("");

    lines.push(`## Cost chart: under / over staffing`);
    lines.push(`**Chart inputs**`);
    lines.push(`- Recommended: **${Math.round(recFte*2)/2} FTE** · Actual: **${Math.round(fteActual*2)/2} FTE**`);
    lines.push(`- Cost/FTE/year: **${money(costFteYear)}** · Horizon: **${horizonMonths} months** · Risk multiplier: **${riskMultiplier.toFixed(1)}×**`);
    lines.push("");
    lines.push(`**Results (estimate)**`);
    lines.push(`- Recommended total: **${money(costRec.total)}** (salary ${money(costRec.salaryCost)} · under-penalty ${money(costRec.underPenalty)} · waste ${money(costRec.overWaste)})`);
    lines.push(`- Actual total: **${money(costAct.total)}** (salary ${money(costAct.salaryCost)} · under-penalty ${money(costAct.underPenalty)} · waste ${money(costAct.overWaste)})`);
    lines.push(`- Delta (Actual − Recommended): **${costDelta>=0?"+":"−"}${money(Math.abs(costDelta))}** over ${horizonMonths} months`);
    lines.push("");

    lines.push(`## Time-to-production chart vs team size`);
    lines.push(`**Chart inputs**`);
    lines.push(`- Scope multiplier: **${scopeMultiplier.toFixed(1)}×** · Handoff tax: **${tax.toFixed(2)}** · Working days/week: **${wdPerWeek}**`);
    lines.push("");
    lines.push(`**Results (estimate)**`);
    lines.push(`- Recommended: **${fmtWorkdays(wdRec)}**`);
    lines.push(`- Actual: **${fmtWorkdays(wdAct)}**`);
    lines.push(`- Delta (Actual − Recommended): **${wdDelta>=0?"+":"−"}${fmtWorkdays(Math.abs(wdDelta))}**`);
    lines.push("");

    lines.push(`## Notes`);
    lines.push(`- Heuristics are for trade-offs (risk/inefficiency/coordination). Validate with real constraints, dependencies and delivery data.`);
    lines.push(`- For high-criticality systems, prioritize on-call readiness, incident response, compliance evidence, and security controls early.`);
    return lines.join("\\n");
  }

  function getLastState(){
    if(currentState) return currentState;
    try{
      const raw = localStorage.getItem("devsecops_team_sizer:last");
      if(raw) return JSON.parse(raw);
    }catch(e){}
    return null;
  }

  function showCopyDialog(md){
    let overlay = document.getElementById("copyOverlay");
    if(!overlay){
      overlay = document.createElement("div");
      overlay.id = "copyOverlay";
      overlay.style.position = "fixed";
      overlay.style.inset = "0";
      overlay.style.background = "rgba(0,0,0,.55)";
      overlay.style.backdropFilter = "blur(6px)";
      overlay.style.zIndex = "10000";
      overlay.style.display = "flex";
      overlay.style.alignItems = "center";
      overlay.style.justifyContent = "center";
      overlay.innerHTML = `
        <div style="width:min(860px, calc(100% - 24px)); background: rgba(15,23,48,.98); border:1px solid rgba(255,255,255,.14); border-radius:16px; padding:14px; box-shadow: 0 10px 30px rgba(0,0,0,.35);">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
            <div style="color: rgba(233,237,245,.95); font-weight:800;">Manual copy</div>
            <button id="copyOverlayClose" class="secondary" style="padding:8px 10px; border-radius:12px;">Close</button>
          </div>
          <div style="color: rgba(169,180,207,.95); font-size:12px; margin-top:8px; line-height:1.45;">
            Browsers may block Clipboard API on <span style="font-family: ui-monospace;">file://</span>. Select the text and copy with <b>Ctrl+C</b> (or Cmd+C).
          </div>
          <textarea id="copyOverlayArea" style="width:100%; margin-top:10px; height: 320px; border-radius:12px; border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.18); color: #e9edf5; padding:10px; font-family: ui-monospace; font-size:12px; outline:none;"></textarea>
        </div>
      `;
      document.body.appendChild(overlay);
      overlay.querySelector("#copyOverlayClose").addEventListener("click", () => overlay.remove());
      overlay.addEventListener("click", (e) => { if(e.target === overlay) overlay.remove(); });
    }
    const area = overlay.querySelector("#copyOverlayArea");
    area.value = md;
    area.focus();
    area.select();
  }

  function fallbackCopyText(textToCopy){
    try{
      const ta = document.createElement("textarea");
      ta.value = textToCopy;
      ta.setAttribute("readonly","");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      ta.style.top = "0";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      if(ok){ toast("Markdown report copied to clipboard."); return true; }
    }catch(e){}
    showCopyDialog(textToCopy);
    return false;
  }

  function copyMarkdown(){
    let state = getLastState();
    if(!state) state = calculate();
    const md = buildMarkdownReport(state);
    if(navigator.clipboard && typeof navigator.clipboard.writeText === "function"){
      navigator.clipboard.writeText(md).then(() => toast("Markdown report copied to clipboard."))
        .catch(() => fallbackCopyText(md));
      return;
    }
    fallbackCopyText(md);
  }

  function downloadJson(){
    let state = getLastState();
    if(!state) state = calculate();
    const blob = new Blob([JSON.stringify(state, null, 2)], { type:"application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "devsecops-team-sizer.json";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function wireChartInputs(){
    const ids = ["fteActual","costFteYear","horizonMonths","riskMultiplier","scopeMultiplier","handoffTax","workDaysPerWeek"];
    ids.forEach(id=>{
      const e = el(id);
      if(!e) return;
      const onAny = () => updateCharts();
      e.addEventListener("input", onAny);
      e.addEventListener("change", onAny);
    });
  }

  // -----------------------------
  // Buttons
  el("btnCalc").addEventListener("click", () => { calculate(); });
  el("btnDownloadJson").addEventListener("click", () => { downloadJson(); });

  el("btnExample").addEventListener("click", () => {
    el("pattern").value = "microservices";
    el("maturity").value = "1";
    el("traffic").value = "120";
    el("trafficUnit").value = "rps";
    el("compute").value = "7";
    el("risk").value = "9";
    el("bias").value = "balanced";
    syncSliders();
    // select more tech
    ["frontend","api","grpc","sqldb","cache","broker","stream","k8s","iac","obs","sec","cicd"].forEach(id => selectedTech.add(id));
    // refresh chip UI
    document.querySelectorAll(".chip").forEach(ch => {
      const id = ch.dataset.id;
      if(selectedTech.has(id)) ch.classList.add("on");
      else ch.classList.remove("on");
    });
    calculate();
    toast("Example loaded.");
  });

  el("btnSave").addEventListener("click", () => {
    const state = getLastState() || calculate();
    try{
      localStorage.setItem("devsecops_team_sizer:scenario", JSON.stringify(state));
      toast("Scenario saved (localStorage).");
    }catch(e){
      toast("Could not save scenario.");
    }
  });

  el("btnReset").addEventListener("click", () => {
    try{
      localStorage.removeItem("devsecops_team_sizer:last");
      localStorage.removeItem("devsecops_team_sizer:scenario");
    }catch(e){}
    location.reload();
  });

  // -----------------------------
  // Init: load saved scenario if present
  function init(){
    wireChartInputs();
    try{
      const saved = localStorage.getItem("devsecops_team_sizer:scenario");
      if(saved){
        const state = JSON.parse(saved);
        // apply inputs
        el("pattern").value = state.input.pattern;
        el("maturity").value = String(state.input.maturity);
        el("traffic").value = String(state.input.traffic);
        el("trafficUnit").value = state.input.trafficUnit;
        el("compute").value = String(state.input.compute);
        el("risk").value = String(state.input.risk);
        el("bias").value = state.input.bias;
        syncSliders();

        selectedTech.clear();
        (state.input.tech||[]).forEach(id => selectedTech.add(id));
        document.querySelectorAll(".chip").forEach(ch => {
          const id = ch.dataset.id;
          if(selectedTech.has(id)) ch.classList.add("on");
          else ch.classList.remove("on");
        });

        // render using stored computed state or recalc for safety
        calculate();
      } else {
        calculate(); // initial baseline
      }
    }catch(e){
      calculate();
    }
  }

  init();
})();
</script>
</body>
</html>
